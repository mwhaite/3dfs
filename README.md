# 3dfs

3dfs is a PySide6 desktop shell for managing, previewing, and customising 3D asset libraries. The application persists asset metadata, tags, and derivative relationships in SQLite while storing managed asset copies under a configurable library root.

## Features

* Repository browser, preview pane, project workspace, and tag sidebar built with PySide6 widgets for a cohesive desktop experience.
* Thumbnail extraction, metadata inspection, and an integrated OpenGL viewer for STL, OBJ, PLY, GLB/GLTF, and FBX meshes (FBX requires the Autodesk FBX SDK; other meshes rely on `trimesh`). STEP assets render via bounding boxes when full meshes are unavailable.
* Parametric customization pipeline with an OpenSCAD backend that records derivative assets and parameter schemas.
* Project inspector that discovers arrangement scripts, attachments, and readme notes with live filesystem refresh.
* Pluggable importer that handles local files and remote identifiers via fetcher plugins and records detailed mesh metadata.
* Persistent tagging, search, and derivative navigation backed by the asset service and tag store.

## Getting Started

1. Quick setup and launch:

   ```bash
   ./setup.sh
   ```

   This creates `.venv`, installs dependencies, and runs the desktop shell. Use `./setup.sh --activate` or `source setup.sh` to keep the environment active.

2. Run the automated checks:

   ```bash
   hatch run lint
   hatch run test
   ```

3. Launch the application after setup or from an activated environment:

   ```bash
   hatch run three-dfs
   # or
   python -m three_dfs
   ```

4. Project layout:

   ```text
   .
   ├── docs/                  # Architecture and workflow documentation
   ├── src/three_dfs/         # Application package (UI, importer, storage, customizer, ...)
   ├── tests/                 # Pytest suite
   ├── pyproject.toml         # Build system, dependencies, tooling config
   └── README.md              # This document
   ```

## User interface overview

### Repository explorer & tag sidebar

The main window loads persisted assets into a searchable repository list. Context menus expose operations such as opening folders or toggling the repository sidebar. The tag sidebar keeps the active item's tags in sync with the underlying store, supports add/edit/delete workflows, emits search events, and exposes derivative assets generated by the customization pipeline for quick navigation.

### Preview and customization

Selecting an asset populates the preview pane with thumbnails, metadata, and optional descriptions. The pane can switch between a cached thumbnail, an interactive OpenGL model viewer for `.stl`, `.obj`, `.ply`, `.fbx`, `.gltf`, or `.glb` meshes, and README content shipped alongside projects. FBX rendering requires the Autodesk FBX SDK while the other mesh formats use `trimesh`; when either dependency is missing or the model fails to parse the 3D tab is disabled with an explanatory tooltip and the metadata callout documents the limitation. Text previews follow the same approach, disabling the tab with a message when a format cannot be decoded so users never land on an empty view. When an asset is backed by a supported backend (such as OpenSCAD), the pane shows customization summaries, launchers, and embeds the customizer panel, surfacing parameter schemas, previous runs, and derivative actions without leaving the view.

### Project workspace

Projects open in a dedicated pane that lists components, attachments, and arrangement scripts. Each project corresponds to a directory inside the configured library root and the application treats its immediate children as parts. Users can search parts, refresh the current folder, launch attachments, or navigate to nested directories. Arrangement scripts discovered under `arrangements/` or `_arrangements/` get grouped automatically, while README files and breadcrumb navigation help document complex builds. A filesystem watcher keeps the pane in sync with on-disk changes.

## Asset library & storage

Asset metadata is persisted in SQLite (`~/.3dfs/assets.sqlite3` by default) and managed through the `AssetService`. The service tracks tags, customizations, derivative relationships, and thumbnail caches while exposing helpers to bootstrap demo data and iterate tagged assets. All managed copies live under the configured library root, ensuring reproducible paths across sessions.

## Importing assets

Use `three_dfs.importer.import_asset` to register local files or remote identifiers. The importer copies supported formats (`.stl`, `.obj`, `.step`, `.stp`) into managed storage, extracts mesh metadata such as vertex/face counts and bounding boxes with `trimesh`, and records provenance fields on the resulting asset. When a path cannot be resolved locally the importer delegates to registered plugins, normalises returned metadata, and enforces that the fetched asset matches one of the supported extensions.

## Customization workflow

The `three_dfs.customizer` package exposes a protocol for parameterised backends and an execution pipeline that stages builds under the managed library. When a customization runs, the pipeline records the parameter schema and values, persists generated artifacts as derivative assets, and links them back to the source customization for status tracking. The preview pane embeds the customizer dialog so users can rerun prior configurations, inspect parameter summaries, and open derivative outputs directly from the UI.

## Projects

Project folders can declare arrangement scripts inside `arrangements/` or `_arrangements/` directories. The discovery helpers merge newly found scripts with stored metadata, preserve custom labels, and ignore stale entries. Components classified as directories trigger navigation, while attachments remain accessible through context actions. The desktop shell watches project folders for changes and refreshes metadata after a short debounce so arrangement previews stay current.

## Tagging and search

`three_dfs.data.tags.TagStore` provides CRUD helpers for assigning tags to repository items. Tags are normalised, stored alongside assets, and exposed via sidebar search. The sidebar also surfaces derivative assets generated by customizations, allowing users to navigate from a base asset to its produced variants without rescanning the library.

## Configuration

- Library root: defaults to `~/Models`. Override with `THREE_DFS_LIBRARY_PATH`.
- Demo entries: set `THREE_DFS_BOOTSTRAP_DEMO=1` to seed example assets.
- Database: remove `~/.3dfs/assets.sqlite3` while the app is closed to reset the repository.
- Importer storage: by default mirrors the configured library root; override per import via `storage_root`.

## Import plugins

Plugins implement the `ImportPlugin` protocol from `three_dfs.import_plugins`. Each plugin advertises `can_handle(source: str) -> bool` and `fetch(source: str, destination: Path) -> Metadata`, then registers itself either by calling `register_plugin` or via the `three_dfs.import_plugins` entry point group. During remote imports the first plugin reporting capability downloads the asset into the provided destination, returning metadata (for example `remote_source`, `extension`, `label`) which the importer merges into the stored record.

The `scaffold_plugin` helper generates boilerplate modules:

```python
from pathlib import Path
from three_dfs.import_plugins import scaffold_plugin

plugin_path = scaffold_plugin("Sketchfab", Path("./plugins"))
print(f"Plugin scaffold written to {plugin_path}")
```

Fill in the generated TODO hooks, ensure the plugin writes the fetched file to the supplied destination, and expose the module via an entry point to make it discoverable.
